#!/bin/bash

SOURCES="../common/test_send ../common/test_output ../common/test_log ../common/test_service ../common/test_check"

IPTABLES_SAVE_FILE="/tmp/sailfish_iptables.filter.$RANDOM"

REQUIRED_COMMANDS_BASE="dbus-send grep id dirname"
REQUIRED_COMMANDS_ROOT="$REQUIRED_COMMANDS_BASE iptables iptables-save iptables-restore systemctl"

# -t filter -L INPUT |grep ACCEPT
METHODS_INPUT_ACCEPT="
AllowIncomingIp
AllowIncomingIpWithPort
AllowIncomingIpWithPortRange
AllowIncomingPort
AllowIncomingPortRange
AllowIncomingIpWithService
AllowIncomingService
"

# -t filter -L OUTPUT |grep ACCEPT
METHODS_OUTPUT_ACCEPT="
AllowOutgoingIp
AllowOutgoingIpWithPort
AllowOutgoingIpWithPortRange
AllowOutgoingPort
AllowOutgoingPortRange
AllowOutgoingIpWithService
AllowOutgoingService"

# -t filter -L INPUT |grep DROP
METHODS_INPUT_DROP="
DenyIncomingIp
DenyIncomingIpWithPort
DenyIncomingIpWithPortRange 
DenyIncomingPort
DenyIncomingPortRange
DenyIncomingIpWithService
DenyIncomingService"

# -t filter -L OUTPUT |grep DROP
METHODS_OUTPUT_DROP="
DenyOutgoingIp
DenyOutgoingIpWithPort
DenyOutgoingIpWithPortRange
DenyOutgoingPort
DenyOutgoingPortRange
DenyOutgoingIpWithService
DenyOutgoingService"

# Inputs for the methods
METHOD_INPUTS[0]='string:192.168.10.1'
METHOD_INPUTS[1]='string:192.168.10.1 uint16:22 string:tcp'
METHOD_INPUTS[2]='string:192.168.10.1 string:80:90 string:tcp'
METHOD_INPUTS[3]='uint16:8080 string:tcp'
METHOD_INPUTS[4]='string:8088:8090 string:tcp'
METHOD_INPUTS[5]='string:192.168.10.1 string:telnet string:tcp'
METHOD_INPUTS[6]='string:telnet string:tcp'

METHOD_INPUTS_RESULT[0]='0'
METHOD_INPUTS_RESULT[1]='0'
METHOD_INPUTS_RESULT[2]='0'
METHOD_INPUTS_RESULT[3]='0'
METHOD_INPUTS_RESULT[4]='0'
METHOD_INPUTS_RESULT[5]='0'
METHOD_INPUTS_RESULT[6]='0'

CLEAR_RESULT="0"
POLICY_RESULT="0"

METHOD_VERIFY_IN[0]='-s 192.168.10.1/32'
METHOD_VERIFY_IN[1]='-s 192.168.10.1/32 -p tcp -m tcp --dport 22'
METHOD_VERIFY_IN[2]='-s 192.168.10.1/32 -p tcp -m tcp --dport 80:90'
METHOD_VERIFY_IN[3]='-p tcp -m tcp --dport 8080'
METHOD_VERIFY_IN[4]='-p tcp -m tcp --dport 8088:8090'
METHOD_VERIFY_IN[5]='-s 192.168.10.1/32 -p tcp -m tcp --dport 23'
METHOD_VERIFY_IN[6]='-p tcp -m tcp --dport 23'

METHOD_VERIFY_OUT[0]='-d 192.168.10.1/32'
METHOD_VERIFY_OUT[1]='-d 192.168.10.1/32 -p tcp -m tcp --dport 22'
METHOD_VERIFY_OUT[2]='-d 192.168.10.1/32 -p tcp -m tcp --dport 80:90'
METHOD_VERIFY_OUT[3]='-p tcp -m tcp --dport 8080'
METHOD_VERIFY_OUT[4]='-p tcp -m tcp --dport 8088:8090'
METHOD_VERIFY_OUT[5]='-d 192.168.10.1/32 -p tcp -m tcp --dport 23'
METHOD_VERIFY_OUT[6]='-p tcp -m tcp --dport 23'

EMPTY_IPTABLES[0]='# Generated by connman.*'
EMPTY_IPTABLES[1]='*filter'
EMPTY_IPTABLES[2]=':INPUT ACCEPT.*'
EMPTY_IPTABLES[3]=':FORWARD ACCEPT.*'
EMPTY_IPTABLES[4]=':OUTPUT ACCEPT.*'
EMPTY_IPTABLES[5]='COMMIT'
EMPTY_IPTABLES[6]='# Completed on.*'

CONNMAN_SAVE_FILE="/var/lib/connman/iptables/rules.v4"

function include_sources()
{
	SCRIPTDIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

	for SRC in $SOURCES ; do
		if [ -f "$SCRIPTDIR/$SRC" ] ; then
			source "$SCRIPTDIR/$SRC"
		else
			echo "Source file \"$SCRIPTDIR/$SRC\" not available. Quitting."
			exit 1
		fi
	done
}

# $1=CHAIN $2=DROP/ACCEPT $3 -> rule line 
function check_save_file_rule()
{	
	if [[ $(grep -e "-A $1 ${@:3} -j $2" $CONNMAN_SAVE_FILE) ]] ; then
		echo 0
	else
		echo "check_save_file_rule() failure :: grep -e -A $1 ${@:3} -j $2 ::"
	fi
}

# $1=CHAIN $2=POLICY
function check_save_file_policy()
{
	if [[ $(grep -e ":$1 $2" $CONNMAN_SAVE_FILE) ]] ; then
		echo 0
	else
		echo "check_save_file_policy() failure :: grep -e :$1 $2 ::"
	fi
}

# $1=chain $2=target $3...methods
function run_add_rules_test()
{
	INDEX=0
	FAILED=0
	
	test_begin
	
	for METHOD in "${@:3}" ; do
	
		PROCESSED=$(send_message "$METHOD" "ADD" ${METHOD_INPUTS_RESULT[$INDEX]} ${METHOD_INPUTS[$INDEX]})
	
		if [[ "$PROCESSED" != "0" ]] ; then
			log "$PROCESSED"
			FAILED=1
		fi
		
		test_progress
		
		INDEX=$((INDEX+1))
	done
	
	test_end $FAILED
}

function run_check_rules_test()
{
	INDEX=0
	FAILED=0
	
	test_begin
	
	while [[ $INDEX -lt 7 ]] ; do
	
		case "$1" in
			"INPUT")
				CHECK=$(check_save_file_rule "$1" "$2" "${METHOD_VERIFY_IN[$INDEX]}")
				;;
			"OUTPUT")
				CHECK=$(check_save_file_rule "$1" "$2" "${METHOD_VERIFY_OUT[$INDEX]}")
				;;
			*)
				;;
		esac
	
		if [[ "$CHECK" != "0" ]] ; then
			log "$CHECK"
			FAILED=1
		fi
		
		test_progress
		
		INDEX=$((INDEX+1))
	done
	
	test_end $FAILED
}


function run_add_policy_test()
{
	FAILED=0
	
	test_begin
	
	PROCESSED=$(send_message "$1" "$3" $POLICY_RESULT)
	
	test_progress
	
	if [[ "$PROCESSED" != "0" ]] ; then
		log "$PROCESSED"
		FAILED=1
	fi
	
	test_progress
	
	test_end $FAILED
}

function run_clear_test()
{
	FAILED=0
	METHODS="ClearIptablesTable ClearIptablesChains"
	
	test_begin
	
	for METHOD in $METHODS ; do
	
		CLEARED=$(send_message "$METHOD" "filter" "$CLEAR_RESULT")
	
		if [[ "$CLEARED" != "0" ]] ; then
			log "$CLEARED"
			FAILED=$((FAILED+1))
		fi
	
		test_progress
	done
	
	test_end $FAILED
}

function run_clear_test_check()
{
	INDEX=0
	FAILED=0
	
	test_begin
	
	while read line ; do
	
		if [[ ! $(echo "$line"|grep -e "${EMPTY_IPTABLES[$INDEX]}") ]] ; then
			FAILED=$((FAILED+1))
			log "Compare failed: $line - ${EMPTY_IPTABLES[$INDEX]}"
		fi
		
		INDEX=$((INDEX+1))
		test_progress
		
	done < $CONNMAN_SAVE_FILE
	
	test_end $FAILED
}

function run_custom_chain_removed_test()
{
	if [ "$(id -u)" == "0" ] ; then
	
		FAILED=0
		CHAIN="chain1"
	
		test_begin
		
		STATUS=$(send_message "ManageChain" "ADD" "0" "string:filter" "string:$CHAIN")
		
		if [[ "$STATUS" != "0" ]] ; then
			log "$STATUS"
			FAILED=1
		fi
		
		test_progress
		
		STATUS=$(check_chain_added "$CHAIN")
	
		if [[ "$STATUS" != "0" ]] ; then
			log "$STATUS"
			FAILED=$((FAILED+1))
		fi
		
		test_progress
		
		stop_service "connman"
		
		STATUS=$(check_chain_removed "$CHAIN")
	
		if [[ "$STATUS" != "0" ]] ; then
			log "$STATUS"
			FAILED=$((FAILED+1))
		fi
		
		test_progress
		
		start_service "connman"
		
		test_end $FAILED
	fi
}

function run_add_test()
{
	run_add_rules_test "INPUT" "ACCEPT" $METHODS_INPUT_ACCEPT
	run_add_rules_test "OUTPUT" "ACCEPT" $METHODS_OUTPUT_ACCEPT
	run_add_rules_test "INPUT" "DROP" $METHODS_INPUT_DROP
	run_add_rules_test "OUTPUT" "DROP" $METHODS_OUTPUT_DROP
	
	#run_add_policy_test "ChangeInputPolicy" "INPUT" "DROP" 
	
	#run_add_policy_test "ChangeOutputPolicy" "OUTPUT" "ACCEPT"
}

function run_add_test_check()
{
	run_check_rules_test "INPUT" "ACCEPT"
	run_check_rules_test "OUTPUT" "ACCEPT"
	run_check_rules_test "INPUT" "DROP"
	run_check_rules_test "OUTPUT" "DROP"
}

function run_command_checks()
{
	if [ "$(id -u)" == "0" ] ; then
		for command in $REQUIRED_COMMANDS_ROOT ; do
			if [[ ! $(which "$command" 2>/dev/null) ]] ; then
				echo "Command \"$command\" is not found. Tests cannot be run."
				exit 1
			fi
		done
	else # For now user and privileged has same cmd requirements
		for command in $REQUIRED_COMMANDS_PRIV ; do
			if [[ ! $(which "$command" 2>/dev/null) ]] ; then
				echo "Command \"$command\" is not found. Tests cannot be run."
				exit 1
			fi
		done
	fi
}

function run_pre_test_operations()
{
	if [ "$(id -u)" == "0" ] ; then
		echo "Saving current iptables filter table to $IPTABLES_SAVE_FILE"
		iptables-save --table=filter > $IPTABLES_SAVE_FILE
	
		CLEARED=$(send_message "ClearIptablesTable" "filter" $CLEAR_RESULT)
	
		if [[ "$CLEARED" != "0" ]] ; then
			echo "Cannot clear iptables filter table. Test may report invalid results."
		fi
		
		CLEARED=$(send_message "ClearIptablesChains" "filter" "$CLEAR_RESULT")
	
		if [[ "$CLEARED" != "0" ]] ; then
			echo "Cannot clear chains from iptables filter table. Test may report invalid results."
		fi
	fi
}

function run_post_test_operations() 
{
	if [ "$(id -u)" == "0" ] ; then
		CLEARED=$(send_message "ClearIptablesTable" "filter" $CLEAR_RESULT)
	
		if [[ "$CLEARED" != "0" ]] ; then
			echo "Cannot clear iptables filter table."
		fi
		echo "Restoring iptables filter table from $IPTABLES_SAVE_FILE"
		iptables-restore --table=filter < $IPTABLES_SAVE_FILE
		
		stop_service "connman"
		cp -f $IPTABLES_SAVE_FILE $CONNMAN_SAVE_FILE
		start_service "connman"
		
		rm -v $IPTABLES_SAVE_FILE
	fi
}

function run_user_checks()
{
	if [ "$(id -u)" != "0" ] ; then
		echo "This test can be run only as root. Quitting"
		exit 1
	fi
}


function main()
{
	include_sources
	
	prepare_log "save-restore-test"
	
	run_user_checks 
	run_command_checks
	
	run_pre_test_operations
	
	sleep 2

	run_clear_test
	restart_service "connman"
	run_clear_test_check
	
	run_custom_chain_removed_test
	
	run_add_test
	restart_service "connman"
	run_add_test_check
	
	run_post_test_operations
	
	test_finalize $TEST_LOG_FILE
}

main
