#!/bin/bash

IPTABLES_SAVE_FILE="/tmp/sailfish_iptables.filter.$RANDOM"
TEST_LOG_FILE="/tmp/sailfish_iptables.test.log"
REQUIRED_COMMANDS="dbus-send iptables iptables-save iptables-restore"

# -t filter -L INPUT |grep ACCEPT
METHODS_INPUT_ACCEPT="
AllowIncomingIp
AllowIncomingIpWithPort
AllowIncomingIpWithPortRange
AllowIncomingPort
AllowIncomingPortRange
AllowIncomingIpWithService
AllowIncomingService
"

# -t filter -L OUTPUT |grep ACCEPT
METHODS_OUTPUT_ACCEPT="
AllowOutgoingIp
AllowOutgoingIpWithPort
AllowOutgoingIpWithPortRange
AllowOutgoingPort
AllowOutgoingPortRange
AllowOutgoingIpWithService
AllowOutgoingService"

# -t filter -L INPUT |grep DROP
METHODS_INPUT_DROP="
DenyIncomingIp
DenyIncomingIpWithPort
DenyIncomingIpWithPortRange 
DenyIncomingPort
DenyIncomingPortRange
DenyIncomingIpWithService
DenyIncomingService"

# -t filter -L OUTPUT |grep DROP
METHODS_OUTPUT_DROP="
DenyOutgoingIp
DenyOutgoingIpWithPort
DenyOutgoingIpWithPortRange
DenyOutgoingPort
DenyOutgoingPortRange
DenyOutgoingIpWithService
DenyOutgoingService"

# Inputs for the methods
METHOD_INPUTS[0]='string:192.168.10.1'
METHOD_INPUTS[1]='string:192.168.10.1 uint16:22 string:tcp'
METHOD_INPUTS[2]='string:192.168.10.1 string:80:90 string:tcp'
METHOD_INPUTS[3]='uint16:8080 string:tcp'
METHOD_INPUTS[4]='string:8088:8090 string:tcp'
METHOD_INPUTS[5]='string:192.168.10.1 string:telnet string:tcp'
METHOD_INPUTS[6]='string:telnet string:tcp'

# protocol, ip, dpt/spt:port
METHOD_VERIFY[0]='all 192.168.10.1'
METHOD_VERIFY[1]='tcp 192.168.10.1 dpt:22'
METHOD_VERIFY[2]='tcp 192.168.10.1 dpts:80:90'
METHOD_VERIFY[3]='tcp 0.0.0.0 dpt:8080'
METHOD_VERIFY[4]='tcp 0.0.0.0 dpts:8088:8090'
METHOD_VERIFY[5]='tcp 192.168.10.1 dpt:23'
METHOD_VERIFY[6]='tcp 0.0.0.0 dpt:23'

DESTINATION="net.connman"
DBUS_PATH="/org/sailfishos/connman/mdm/iptables"
METHOD_PREFIX="org.sailfishos.connman.mdm.iptables"

TESTCOUNT=1
TESTFAILED=0

function prepare_log()
{
	if [ -f $TEST_LOG_FILE ] ; then
		rm $TEST_LOG_FILE
	fi
}

function log()
{
	echo "Test $TESTCOUNT: $@" >> $TEST_LOG_FILE
}

# $1=CHAIN $2=DROP/ACCEPT $3=proto $4=ip $5=port"
function check_change()
{	
	if [[ $(iptables -t filter -L $1 -n|grep -e "$2.*$3.*--.*$4.*$5") ]] ; then
		echo 0
	else
		echo "failure :: iptables -t filter -L $1 -n|grep -e $6 $2.*$3.*--.*$4.*$5 ::"
	fi
}

# $1=CHAIN $2=DROP/ACCEPT $3=proto $4=ip $5=port"
function check_removed()
{	
	if [[ ! $(iptables -t filter -L $1 -n|grep -e "$2.*$3.*--.*$4.*$5") ]] ; then
		echo 0
	else
		echo "failure :: ! iptables -t filter -L $1 -n|grep -e "$2.*$3.*--.*$4.*$5" ::"
	fi
}

function check_policy_change()
{
	if [[ $(iptables -t filter -L $1 -n|grep -e "Chain $1 (policy $2)") ]] ; then
		echo 0
	else
		echo "failure :: iptables -t filter -L $1 -n|grep -e Chain $1 (policy $2) ::"
	fi
}

# Send dbus message with dbus-send, input: $1=Methodname $2=Whole content
function send_message()
{
	RETURN=$(dbus-send --system --type=method_call --print-reply --dest="$DESTINATION" "$DBUS_PATH" "$METHOD_PREFIX.$1" ${@:3} string:$2 2>&1)
	
	if [[ $RETURN && $(echo $RETURN|grep -e "uint16 0") ]] ; then
		echo 0
	else
		echo "failure processing rule $METHOD_PREFIX.$1 ${@:3} string:$2 - method returned: $RETURN"
	fi
}

# $1=chain $2=target $3...methods
function run_method_test()
{
	INDEX=0

	for METHOD in ${@:3} ; do
	
		FAILED=0
		
		echo -n "Running test $TESTCOUNT "
		PROCESSED=$(send_message $METHOD "ADD" ${METHOD_INPUTS[$INDEX]})
	
		if [[ "$PROCESSED" != "0" ]] ; then
			log "$PROCESSED"
			FAILED=1
		fi
	
		echo -n "."
	
		CHANGE=$(check_change "$1" "$2" ${METHOD_VERIFY[$INDEX]})
	
		if [[ "$CHANGE" != "0" ]] ; then
			log "$CHANGE"
			FAILED=1
		fi
	
		echo -n "."
	
		PROCESSED=$(send_message $METHOD "REMOVE" ${METHOD_INPUTS[$INDEX]})
	
		if [[ "$PROCESSED" != "0" ]] ; then
			log "$PROCESSED"
			FAILED=1
		fi
		
		echo -n "."
	
		CHANGE=$(check_removed "$1" "$2" ${METHOD_VERIFY[$INDEX]})
	
		if [[ "$CHANGE" != "0" ]] ; then
			log "$CHANGE"
			FAILED=1
		fi
	
		echo -n "."
		
		if [ $FAILED -eq 0 ] ; then
			echo " PASS"
		else
			TESTFAILED=$((TESTFAILED+1))
			echo " FAILED"
		fi
	
		TESTCOUNT=$((TESTCOUNT+1))
		INDEX=$((INDEX+1))
	done
}

function run_policy_test()
{
	FAILED=0
	
	echo -n "Running test $TESTCOUNT ."
	
	PROCESSED=$(send_message $1 $3)
	
	echo -n "."
	
	if [[ "$PROCESSED" != "0" ]] ; then
		log "$PROCESSED"
		FAILED=1
	fi
	
	echo -n "."
	
	CHANGE=$(check_policy_change $2 $3)
	
	if [[ "$CHANGE" != "0" ]] ; then
		log "$CHANGE"
		FAILED=1
	fi
	
	echo -n "."
	
	if [ $FAILED -eq 0 ] ; then
		echo " PASS"
	else
		TESTFAILED=$((TESTFAILED+1))
		echo " FAILED"
	fi
		
	TESTCOUNT=$((TESTCOUNT+1))
}

function run_tests()
{
	run_method_test "INPUT" "ACCEPT" $METHODS_INPUT_ACCEPT
	run_method_test "OUTPUT" "ACCEPT" $METHODS_OUTPUT_ACCEPT
	run_method_test "INPUT" "DROP" $METHODS_INPUT_DROP
	run_method_test "OUTPUT" "DROP" $METHODS_OUTPUT_DROP
	
	run_policy_test "ChangeInputPolicy" "INPUT" "DROP" 
	run_policy_test "ChangeInputPolicy" "INPUT" "ACCEPT"
	
	run_policy_test "ChangeOutputPolicy" "OUTPUT" "DROP" 
	run_policy_test "ChangeOutputPolicy" "OUTPUT" "ACCEPT" 
}

function run_command_checks()
{
	for command in $REQUIRED_COMMANDS ; do
		if [[ ! $(which $command) ]] ; then
			echo "Command \"$command\" is not found. Tests cannot be run."
			exit 1
		fi
	done
}

function run_pre_test_operations()
{
	if [ "$(id -u)" == "0" ] ; then
		echo "Saving current iptables filter table to $IPTABLES_SAVE_FILE"
		iptables-save --table=filter > $IPTABLES_SAVE_FILE
	
		CLEARED=$(send_message "ClearIptablesTable" "filter")
	
		if [[ "$CLEARED" != "0" ]] ; then
			echo "Cannot clear iptables filter table. Test may report invalid results."
		fi
	else
		echo "This test script is not run as root."
		echo "Current status of iptables cannot be saved or restored."
	
		echo -n "Clear iptables with D-Bus API method call? [yes/no/quit] "
	
		read response
	
		case $response in
			"yes" | "y")
				CLEARED=$(send_message "ClearIptablesTable" "filter")
				if [[ "$CLEARED" != "0" ]] ; then
					echo "Cannot clear iptables filter table using D-Bus API."
				fi
				;;
			"no" | "n")
				echo "Test may report invalid values if iptables contains similar rules used in testing."
				;;
			"quit" | "q")
				exit 0
				;;
			*)
				echo "Invalid selection. Quitting"
				exit 0
				;;
		esac
	fi
}

function run_post_test_operations() 
{
	if [ "$(id -u)" == "0" ] ; then
		CLEARED=$(send_message "ClearIptablesTable" "filter")
	
		if [[ "$CLEARED" != "0" ]] ; then
			echo "Cannot clear iptables filter table."
		fi
		echo "Restoring iptables filter table from $IPTABLES_SAVE_FILE"
		iptables-restore --table=filter < $IPTABLES_SAVE_FILE
		rm -v $IPTABLES_SAVE_FILE
	else
		echo "Iptables may contain invalid values."
	fi
}

function main()
{
	
	run_command_checks
	run_pre_test_operations
	run_tests
	run_post_test_operations

	if [ $TESTFAILED -eq 0 ] ; then
		echo "All tests complete."
		exit 0
	else
		echo "$TESTFAILED/$TESTCOUNT tests failed."
		echo "Error logs can be found at $TEST_LOG_FILE"
		exit 1
	fi
}

main
